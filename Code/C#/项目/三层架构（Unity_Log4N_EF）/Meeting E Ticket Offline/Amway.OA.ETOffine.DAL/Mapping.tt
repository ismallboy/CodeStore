<#
//<summary>
//数据关系代码生成模板
//</summary>
//<remarks></remarks>
//</history>
#>
<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#><#
 
//System.Diagnostics.Debugger.Launch(); 

CodeGenerationTools code = new CodeGenerationTools(this);
CodeRegion region = new CodeRegion(this, 1);

string namespaceName = code.VsNamespaceSuggestion();
string parentNS = namespaceName.Substring(0,namespaceName.LastIndexOf('.'));
string entityAccessNS = parentNS + ".Entities";
string coreNS = parentNS;
string dataAccessNS = parentNS+".DAL";
string mapNS ="System.Data.Entity.ModelConfiguration";

var inputFile = this.Host.ResolvePath("") + @"\ETOffine.edmx";
var mps = GetMappingTypes(inputFile);

EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

// Write out support code to primary template output file
WriteHeader(fileManager,"System","System.Collections.Generic","System.Linq","System.Text","System.Data.Objects",coreNS,dataAccessNS,entityAccessNS,mapNS);
BeginNamespace(namespaceName, code);
EndNamespace(namespaceName);

// Emit IDAO Types
foreach (var entity in mps)
{	
     fileManager.StartNewFile(entity.EntityType + "Map.Generation.cs");
     BeginNamespace(namespaceName, code);
#>
	/// <summary>
	/// <#=entity.EntityType#>数据访问组件
	/// </summary>
	<#="public class " + entity.EntityType#>Map : EntityTypeConfiguration<#="<" + entity.EntityType + ">"#>
	{
		public <#=entity.EntityType#>Map()
		{
			this.ToTable("<#=entity.TableName#>");

	<#
	foreach (var col in entity.Mappings)
	{
	#>
		this.Property(t => t.<#=col.Name#>).HasColumnName("<#=col.ColumnName#>");
	<#
	}
	#>
	}
	}
<#
	EndNamespace(namespaceName);	
}
fileManager.Process();
#>

<#+

void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#=String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        //PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        //PopIndent();
#>
}
<#+
    }
}

// Set recordRequiredOriginalValuesOnly to false in the OriginalValueMembers constructor in order to always record all original values
public class OriginalValueMembers
{
    private readonly HashSet<EdmProperty> _concurrencyMembers;

    public OriginalValueMembers(bool recordRequiredOriginalValuesOnly, MetadataWorkspace metadataWorkspace, MetadataTools metadataTools)
    {
        if (recordRequiredOriginalValuesOnly)
        {
            try
            {
                _concurrencyMembers = new HashSet<EdmProperty>();
                foreach (EntityContainer container in metadataWorkspace.GetItems<EntityContainer>(DataSpace.CSpace))
                {
                    ILookup<EntityType, EntityType> directSubTypeLookup = metadataWorkspace.GetItems<EntityType>(DataSpace.CSpace).ToLookup(e => (EntityType)e.BaseType);
                    foreach (EntitySetBase eSet in container.BaseEntitySets.Where(es => es.BuiltInTypeKind == BuiltInTypeKind.EntitySet))
                    {
                        List<EntityType> subTypes = new List<EntityType>();
                        GetSubtypes(directSubTypeLookup, (EntityType)eSet.ElementType, subTypes);
                        foreach (EntityType eType in subTypes)
                        {
                            foreach (EdmProperty member in metadataWorkspace.GetRequiredOriginalValueMembers(eSet, eType))
                            {
                                _concurrencyMembers.Add(member);
                            }
                        }
                    }
                }

                // GetRequiredOriginalValueMembers will not always return foreign key properties, but they are required
                foreach (AssociationType assoc in metadataWorkspace.GetItems<AssociationType>(DataSpace.CSpace).Where(a => a.IsForeignKey))
                {
                    foreach (EdmProperty toProperty in assoc.ReferentialConstraints[0].ToProperties)
                    {
                        _concurrencyMembers.Add(toProperty);
                    }
                }
            }
            catch (Exception)
            {
                // If any exceptions occur, fall back to always recording original values for all properties
                _concurrencyMembers = null;
            }
        }
    }

    public bool IsOriginalValueMember(EdmProperty edmProperty)
    {
        return _concurrencyMembers == null || _concurrencyMembers.Contains(edmProperty);
    }

    private static void GetSubtypes(ILookup<EntityType, EntityType> lookup, EntityType eType, List<EntityType> subTypes)
    {
        subTypes.Add(eType);
        foreach (EntityType subType in lookup[eType])
        {
            GetSubtypes(lookup, subType, subTypes);
        }
    }
}

public XElement ReadFile(string inputFiles)
{
    //string appPath = AppDomain.CurrentDomain.BaseDirectory + "\\" + inputFiles;
    var doc = XDocument.Load(inputFiles);
    var root = doc.Element("{http://schemas.microsoft.com/ado/2008/10/edmx}Edmx");
    return root.Element("{http://schemas.microsoft.com/ado/2008/10/edmx}Runtime");
}

public IEnumerable<XElement> GetMapping(XElement runtime)
{
    var mappings = runtime.Element("{http://schemas.microsoft.com/ado/2008/10/edmx}Mappings");
    var mapping = mappings.Element("{http://schemas.microsoft.com/ado/2008/09/mapping/cs}Mapping");
    var entityContainerMapping = mapping.Elements("{http://schemas.microsoft.com/ado/2008/09/mapping/cs}EntityContainerMapping");
    return entityContainerMapping.Elements("{http://schemas.microsoft.com/ado/2008/09/mapping/cs}EntitySetMapping");
}

public List<TableMapping> GetMappingTypes(string inputFiles)
{
    var runtime = ReadFile(inputFiles);
    var mappings = GetMapping(runtime);
    var tableMappings = new List<TableMapping>();
    foreach (var xElement in mappings)
    {
        var tableMapping = new TableMapping();
        var model = xElement.Elements().First();
        var table = model.Elements().First();
        tableMapping.TableName = table.Attribute("StoreEntitySet").Value;
		var typeName =model.Attribute("TypeName").Value;
        tableMapping.EntityType = typeName.Substring(typeName.LastIndexOf(".") + 1);

        var scalarPropertyMappings = new List<ScalarProperty>();
        foreach (var element in table.Elements())
        {
            var sProperty = new ScalarProperty();
            sProperty.Name = element.Attribute("Name").Value;
            sProperty.ColumnName = element.Attribute("ColumnName").Value;
            scalarPropertyMappings.Add(sProperty);
        }
        tableMapping.Mappings = scalarPropertyMappings;
		tableMappings.Add(tableMapping);
    }
	return tableMappings;
}

public class TableMapping
{
    public string TableName { get; set; }
    public string EntityType { get; set; }
    public List<ScalarProperty> Mappings { get; set; }
}
public class ScalarProperty
{
    public string Name { get; set; }
    public string ColumnName { get; set; }
}

#>